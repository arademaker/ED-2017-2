# aula 5

> assignments
> - ler sobre mergesort

continuar no capítulo II (Dasgupta)

## divide and conquer algorithms

recursão é ferramenta fundamental para resolver problemas usando a técnica de divide and conquer

### teorema fundamental da recursão

trabalho feito em cada nível da recursão:

$$a^k O(\frac{n}{b^k})^d = O(n^d) (\frac{a}{b^d})^k$$

a é o número de subproblemas em que dividimos em cada problema, logo a cada nível temos $a^k$ subproblemas. vale lembrar que só resolvemos o problema nas folhas da árvore, então o custo a cada nível é meramente unir os resultados de cada subproblema do nível, por isso $O(\frac{n}{b^k})^d$ (cada subproblema tem tamanho $\frac{n}{b^k}$).

> as k goes from 0 (root) to $\log_bn$ (leaves), this forms a geometric progression with ratio $r = \frac{a}{b^d}$.

se r é menor que 1: then the series is decreasing, and its sum is just given by its first term, O($n^d$).
se r é maior que 1: the series is increasing and its sum is given by its last term, $O(n^{\log_ba})$
se r é igual a 1: in this case all $O(\log n)$ terms of the series are equal to $O(n^d)$

três casos: $$\begin{cases}
O(n^d) & \mathit{if} \quad d > \log_b a \\
O(n^d\log n) & \mathit{if} \quad d = \log_b a \\
O(n^{\log_ba}) & \mathit{if} \quad d < \log_b a\end{cases}$$

### Mergesort

Dasgupta cap. 2

### Implementações

#### mergesort
- [cl](https://github.com/odanoburu/ED-2017-2/blob/master/src/mergesort.lisp)
- [R](https://github.com/oilujcesarv/ED-2017-2/blob/master/src/Mergesort.R)
- [Python](https://github.com/alsombra/ED-2017-2/blob/master/src/mergesort.ipynb)
