# aula 7
> 2017-07-25
## grafos

- simplificações de problemas: [colorir mapa](https://en.wikipedia.org/wiki/Four_color_theorem), pontes de konigsberg, etc.
- problemas "naturalmente" modelados como grafos (como os de conectividade, e.g. redes sociais)

Exemplos : Conectividade, modelar o problema como um grafo e identificar quais os nós que se removidos do grafo vão tornar os garfos desconexos (nós mais relevantes) etc. Banco de dados noSQL(couchDB, mongoDB, RethinkDB), toda tabela pode ser transformada em grafo muito fácil, Web Semântica (procurar [RDF Primer W3](https://www.w3.org/TR/2004/REC-rdf-primer-20040210/) - todo tipo de informação pode ser representada como Grafo)

- Formas de armazenar grafos
    - Matriz quadrada: representando os nós e arestas
        - Positivo: encontrar as relações, seja olhando pra linha ou diretamente para posição ($O(1)$)
        - Negativo: espaço para armazenar já que as matrizes precisam ser quadradas(matrizes podem ser esparsas) e adição de um nó iria mudar a estrutura toda (dualidade com vetor x lista encadeada com matriz de adjacência x rep grafo com listas encadeadas)
    - Lista encadeada: com as ligações para cada elemento da lista
    - Lista de listas encadeadas (não permite grafos com nós sem conexões)
    - Várias outras formas (no livro Python Algorithms)

### depth-first search

> what parts of the graph are reachable from a given vertex?

    def explore(graph, node):
        node.visited = True
        pre-visit(node)
        for every neighbour of node:
            if not neighbour.visited:
                explore(graph, neighbour)
        post-visit(node)
        
> Complexidade: $O(n+m)$ 
> n = # de nós , m = # de arestas

### representação

- orientação à objetos: nós como classes ou estruturas

- simbólica: representação direta na estrutura de dados, em lista de listas ou matrizes, por exemplo.

### Tipos de Grafos

- Direcionado (possui arestas de cross,forward, back -> pode-se verificar pela ordem dos pre/pos)

    - Direcionado Acíclico (DAG) 
        - ex: Make, pre requisitos de inscrição de matérias (aplicação de verificar se o grafo é um DAG para verificar se não tem situação irreal)
        - Verifica-se se o grafo é um DAG ou não fazendo o DFS e, se tiver aresta de BACK, será um DAG.
            - Algoritmo de linearização: retorna o grafo linearizado ou não, dizendo que não é um DAG
                    - Complexidade = $O(n+m) + O(n\log n)$
            - Um grafo que é um DAG permite mais de uma linearização.

### Dever de casa:

- Dado um Grafo quero saber se é um DAG e se for quais linearizações diferentes ele possui.

- Ler 3.4 Strongly Connected Components para discutir aula que vem

- Pensar sobre o problema do projeto
